import copy


def gauss(A, B):
    """    Функция находит решение СЛАУ с квадратной матрицей коэффициентов при переменных.

    В качестве аргументов функция принимает квадратную матрицу коэффициентов при переменных в виде списка списков
    и вектор свободных коэффициентов в виде списка. Алгоритм приводит матрицу коэффициентов к верхне-треугольному виду
    путем перестановок уравнений и вычитания одного уравнения, домноженного на коэффициент, из другого.
    После этого преобразования если коэффициент в последнем уравнении при последней
    неизвестной равен нулю и свободный коэффициент в этом уравнении тоже равен нулю, то СЛАУ имеет бесконечное
    множество решений, а если свободный коэффициент в этом уравнении не равен нулю, то СЛАУ не имеет решений.
    Если коэффициент в последнем уравнении при последней неизвестной не равен нулю, то система имеет единственное решение,
    и оно находится методом подстановки найденной из последнего уравнения последней неизвестной в предыдущее уравнение
    и дальнейшей подстановки известных значений переменных в предыдущие уравнения. Функция возвращает список,
    содержащий единственное решение системы, либо, если СЛАУ имеет бесконечное множество решений либо не имеет их вовсе,
    ошибку с соответствующим сообщением."""
    if len(A) == len(A[0]) == len(B):
        l = len(A)
        for i in range(l-1):
            n = i + 1
            while A[i][i] == 0:
                A[i], A[n] = A[n], A[i]
                B[i], B[n] = B[n], B[i]
                if n > l:
                    raise ValueError('At least one of the coefficients of a variable should not be zero')
                n += 1
            norm = A[i][i]
            for k in range(l):
                A[i][k] /= norm
            B[i] /= norm
            for j in range(i+1, l):
                koef = A[j][i]
                for k in range(l):
                    A[j][k] -= A[i][k] * koef
                B[j] -= B[i] * koef
        X = []
        for i in range(l):
            X.append(0)
        if B[l-1] == 0 and A[l-1][l-1] == 0:
            raise ValueError('The system has infinitely many solutions')
        elif B[l-1] != 0 and A[l-1][l-1] == 0:
            raise ValueError('The system has no solution')
        X[l-1] = B[l-1] / A[l-1][l-1]
        for i in range(l-1, -1, -1):
            for j in range(l):
                X[i] -= A[i][j] * X[j]
            X[i] += B[i]
        return X


def slau_drop_null(A, B):
    """    Функция удаляет из СЛАУ, записанной в матричном виде, уравнения, все коэффициенты которых равны нулю.

    В качестве аргументов функция принимает квадратную матрицу коэффициентов при переменных в виде списка списков
    и вектор свободных коэффициентов в виде списка и возвращает эту же матрицу и вектор с удаленными нулевыми строками."""
    for i, row in enumerate(A):
        isNull = True
        for element in row:
            if element != 0:
                isNull = False
        if B[i] != 0:
            isNull = False
        if isNull:
            A.pop(i)
            B.pop(i)
    return A, B


def slau_drop_lz(A, B):
    """    Функция удаляет из СЛАУ, записанной в матричном виде, уравнения, которые являются линейно зависимыми
    с другими уравнениями.

    В качестве аргументов функция принимает квадратную матрицу коэффициентов при переменных в виде списка списков
    и вектор свободных коэффициентов в виде списка и возвращает эту же матрицу и вектор с удаленными линейно зависимыми
    строками."""
    A, B = slau_drop_null(A, B)
    if len(A[0]) > 1:
        for i in range(len(B)-1):
            j = i+1
            while j < len(B):
                isLZ = True
                for k in range(1, len(A[j])):
                    if A[j][k-1] != 0 and A[j][k] != 0 and A[i][k-1] / A[j][k-1] != A[i][k] / A[j][k]:
                        isLZ = False

                if A[i][0] != 0 and B[i] != 0 and B[j] / B[i] != A[j][0] / A[i][0]:
                    isLZ = False

                if isLZ:
                    A.pop(j)
                    B.pop(j)
                else:
                    j += 1
    return A, B


def slau(A, B):
    """    Функция находит решение СЛАУ.

    В качестве аргументов функция принимает матрицу коэффициентов при переменных в виде списка списков
    и вектор свободных коэффициентов в виде списка. Создаются копии этих матрицы и вектора, и из них
    удаляются нулевые и линейно зависимые строки при помощи функций slau_drop_null и slau_drop_lz. После этого,
    если матрица коэффициентов при переменных квадратная, то решение находится с помощью вызова функции gauss,
    если уравнений больше, чем неизвестных, то СЛАУ является переопределенной и не имеет решений,
    так как линейно зависимые и нулевые строки отсутствуют, а если уравнений меньше, чем неизвестных,
    то по теореме Кронекера - Капелли если ранг матрицы коэффициентов при переменных равен рангу расширенной
    матрицы системы, то она имеет бесконечное множество решений, а если не равен, то система не имеет решений.
    Функция возвращает список, содержащий решение системы, либо ошибку с сообщением о бесконечном множестве
    решений либо об их отсутствии."""
    M = copy.deepcopy(A)
    V = copy.deepcopy(B)
    M, V = slau_drop_lz(M, V)
    if len(M) == len(M[0]) == len(V):
        solution = gauss(M, V)
        return solution
    elif len(M) == len(V) and len(M) < len(M[0]):
        rank = len(M)
        extrank = len(V)
        for i, row in enumerate(M):
            isNull = True
            for element in row:
                if element != 0:
                    isNull = False
            if isNull:
                rank -= 1
        if rank != extrank:
            raise ValueError('The system is underdetermined and has no solution')
        else:
            raise ValueError('The system is underdetermined and has infinitely many solutions')
    elif len(M) == len(V) and len(M) > len(M[0]):
        raise ValueError('The system is overdetermined and has no solution')
    else:
        raise ValueError('Incorrect dimensions')
